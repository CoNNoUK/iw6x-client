dependencies = {
	basePath = "./deps"
}

function dependencies.load()
	dir = path.join(dependencies.basePath, "premake/*.lua")
	deps = os.matchfiles(dir)

	for i, dep in pairs(deps) do
		dep = dep:gsub(".lua", "")
		require(dep)
	end
end

function dependencies.imports()
	for i, proj in pairs(dependencies) do
		if type(i) == 'number' then
			proj.import()
		end
	end
end

function dependencies.projects()
	for i, proj in pairs(dependencies) do
		if type(i) == 'number' then
			proj.project()
		end
	end
end

newoption {
	trigger = "copy-to",
	description = "Optional, copy the EXE to a custom folder after build, define the path here if wanted.",
	value = "PATH"
}

newoption {
	trigger = "dev-build",
	description = "Enable development builds of the client.",
}

newaction {
	trigger = "generate-buildinfo",
	description = "Sets up build information file like version.h.",
	onWorkspace = function(wks)
		local proc = assert(io.popen("git rev-parse HEAD", "r"))
		local commithash = assert(proc:read('*a')):gsub("%s+", "")
		proc:close()
		
		local oldCommit = "(none)"
		local oldCommitFile = io.open(wks.location .. "/version.txt", "r")
		if oldCommitFile ~= nil then
			oldCommit = assert(oldCommitFile:read('*a'))
			oldCommitFile:close()
		end
		
		if oldCommit ~= commithash then
			local versionFile = assert(io.open(wks.location .. "/version.txt", "w"))
			versionFile:write(commithash)
			versionFile:close()

			local versionHeader = assert(io.open(wks.location .. "/src/version.h", "w"))
			versionHeader:write("/*\n")
			versionHeader:write(" * Automatically generated by premake5.\n")
			versionHeader:write(" * Do not touch, you fucking moron!\n")
			versionHeader:write(" */\n")
			versionHeader:write("\n")
			versionHeader:write("#define GIT_HASH \"" .. commithash .. "\"\n")
			versionHeader:close()
		end
	end
}

dependencies.load()

workspace "iw6x"
	startproject "client"
	location "./build"
	objdir "%{wks.location}/obj"
	targetdir "%{wks.location}/bin/%{cfg.platform}/%{cfg.buildcfg}"

	configurations {
		"Debug",
		"Release",
	}

	architecture "x64"
	platforms "x64"

	buildoptions "/std:c++latest"
	systemversion "latest"
	symbols "On"
	staticruntime "On"
	editandcontinue "Off"
	warnings "Extra"
	characterset "ASCII"
	
	if _OPTIONS["dev-build"] then
		defines {
			"DEV_BUILD",
		}
	end
	
	flags {
		"NoIncrementalLink",
		"NoMinimalRebuild",
		"MultiProcessorCompile",
		"No64BitChecks"
	}

	configuration "windows"
		defines {
			"_WINDOWS",
			"WIN32",
		}

	configuration "Release"
		optimize "Full"
		buildoptions "/Os"

		defines {
			"NDEBUG",
		}

		flags {
			"FatalCompileWarnings",
		}

	configuration "Debug"
		optimize "Debug"

		defines {
			"DEBUG",
			"_DEBUG",
		}

	configuration {}

	project "client"
		kind "ConsoleApp"
		language "C++"
		
		targetname "iw6x"

		pchheader "std_include.hpp"
		pchsource "src/client/std_include.cpp"

		linkoptions {
			"/IGNORE:4254",
			"/DYNAMICBASE:NO",
			"/SAFESEH:NO",
			"/LARGEADDRESSAWARE",
			"/LAST:.main"
		}

		files {
			"./src/client/**.rc",
			"./src/client/**.hpp",
			"./src/client/**.cpp",
			"./src/client/resources/**.*"
		}

		includedirs {
			"./src/client",
			"%{prj.location}/src",
		}

		resincludedirs {
			"$(ProjectDir)src"
		}
		
		dependson {
			"tlsdll",
			"runner"
		}

		prebuildcommands
		{
			"pushd %{_MAIN_SCRIPT_DIR}",
			"tools\\premake5 generate-buildinfo",
			"popd",
		}

		if _OPTIONS["copy-to"] then
			postbuildcommands {
				"copy /y \"$(TargetPath)\" \"" .. _OPTIONS["copy-to"] .. "\""
			}
		end

		dependencies.imports()


	project "tlsdll"
		kind "SharedLib"
		language "C++"
		
		buildoptions {
			"/Zc:threadSafeInit-"
		}

		files {
			"./src/tlsdll/**.rc",
			"./src/tlsdll/**.hpp",
			"./src/tlsdll/**.cpp",
			"./src/tlsdll/resources/**.*"
		}

		includedirs {
			"./src/tlsdll",
			"%{prj.location}/src",
		}

		resincludedirs {
			"$(ProjectDir)src"
		}
		
	project "runner"
		kind "WindowedApp"
		language "C++"
		
		buildoptions {
			"/Zc:threadSafeInit-"
		}

		files {
			"./src/runner/**.rc",
			"./src/runner/**.hpp",
			"./src/runner/**.cpp",
			"./src/runner/resources/**.*"
		}

		includedirs {
			"./src/runner",
			"%{prj.location}/src",
		}

		resincludedirs {
			"$(ProjectDir)src"
		}

	group "Dependencies"
		dependencies.projects()

rule "ProtobufCompiler"
	display "Protobuf compiler"
	location "./build"
	fileExtension ".proto"
	buildmessage "Compiling %(Identity) with protoc..."
	buildcommands {
		'@echo off',
		'path "$(SolutionDir)\\..\\tools"',
		'if not exist "$(ProjectDir)\\src\\proto" mkdir "$(ProjectDir)\\src\\proto"',
		'protoc --error_format=msvs -I=%(RelativeDir) --cpp_out=src\\proto %(Identity)',
	}
	buildoutputs {
		'$(ProjectDir)\\src\\proto\\%(Filename).pb.cc',
		'$(ProjectDir)\\src\\proto\\%(Filename).pb.h',
	}